#include <iostream>
#define MOD 1000000000

using namespace std;

/*
10844번 문제

접근 방식
->
점화식을 세워봤었다.
결론은 n >= 2 일때 n 번째 수 = 2 * (n - 1)번째 수 - 1; (한번 할때마다 상한, 하한에서 -1, 10 으로 갈리기 때문임.) -> 틀렸음.

1 -> 9
2 -> 17 -> 2 * 9 - 1 (이떄는 상한이 9 10 이라 10이 안되서 걸림)
3 -> 32 -> 2 * 17 - 2 (이떄는 하한이 1 0 -1 이라 -1이 안되서 걸림, (1회 오답후 추가) 8 9 10은 상한이 걸려서 안됨.)
4 -> 61 -> 2 * 32 - 3 으로 예측

아래 2문장은 틀린 문장 (1회 채점 전)
2 * n 일때 10 이 걸릴거고,
2 * n + 1일때 -1이 걸릴것.
1회 틀림 -> 저것의 반례가 789 -> 10 이었음. 고로 위의 2문장은 틀린 점화식이 될거임.

이해가 안되서 질문게시판을 보니 점화식 자체가 잘못된거였음;;
0 초과 9 미만 일시 2개씩 올수있음
0 일시 1개만 가능
9 일시 1개만 가능
n번째 배열의 0부터 9까지 다 더해준 값이 '해'가 된다.
*/

/*
조건
n이 주어진다 n은 100이하 자연수
10^9로 나눈 나머지를 출력
*/

/*
태그
. 다이나믹 프로그래밍
*/

/*
느낀점
일부러 코드는 자세히 안봤는데, 2차원 배열을 써서 푼것을 보긴 했으므로 이게 내가 푼것이 맞는지에 대한 의문이 들기 시작했다.
*/

int main()
{
    long long arr[107][17];
    arr[1][0] = 0;
    for (int i = 1; i < 10; i++)
    {
        arr[1][i] = 1;
    }

    for (int i = 2; i < 101; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            if (j < 9 && j > 0) arr[i][j] = (arr[i - 1][j + 1] + arr[i - 1][j - 1]) % MOD;
            if (j == 9) arr[i][j] = (arr[i - 1][j - 1]) % MOD;
            if (j == 0) arr[i][j] = (arr[i - 1][j + 1]) % MOD;
        }
    }

    int n, sum = 0;
    scanf("%d", &n);

    for (int i = 0; i < 10; i++)
    {
        sum += arr[n][i];
        sum %= MOD;
    }
    printf("%lld", sum);
}
